R1 = mtaregime(orders = list(p = 1,q = 0,d = 0),Phi = Phi_R1,Sigma = Sigma_R1,cs=cs_1)
### R2 regimen ====
Phi_R2 = list(phi1 = matrix(c(0.3,0.5,-0.5,0.2,0.7,-0.1,0.3,-0.4,0.8),k,k,byrow = TRUE))
#Beta_R2=list(beta1=matrix(c(0.3,0.5,-0.2,0.7,0.3,-0.5),k,v,byrow = TRUE))
Sigma_R2 = matrix(c(2.5,0.0,0.0,0.0,1,0.0,0.0,0.0,4),k,k,byrow = TRUE)
cs_2=matrix(c(0,0,0),nrow=k)
#R2 = mtaregime(orders = list(p = 1,q = 1,d = 0),
#               Phi = Phi_R2,Beta = Beta_R2,Sigma = Sigma_R2)
R2 = mtaregime(orders = list(p = 1,q = 0,d = 0),
Phi = Phi_R2,Sigma = Sigma_R2,cs=cs_2)
## crea lista de objeto tipo Regime
Rg = list(R1 = R1,R2 = R2)
r = 0.0
extra_1_contaminated=0.9; extra_2_contaminated=0.8
extra_1_contaminated=0.2; extra_2_contaminated=0.3
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
mtar <- function(formula, data, subset, Intercept=TRUE, ars, row.names, dist=c("Gaussian","Student-t","Hyperbolic","Laplace","Slash","Contaminated normal"), prior=list(), n.sim=500, n.burnin=100, n.thin=1, hmin=0, hmax=3,...){
dist <- match.arg(dist)
if(missing(data)) data <- environment(formula)
regim <- length(ars$p)
mmf <- match.call(expand.dots = FALSE)
m <- match(c("formula", "data", "subset", "na.action", "row.names"), names(mmf), 0)
mmf <- mmf[c(1,m)]
mmf$drop.unused.levels <- TRUE
mmf[[1]] <- as.name("model.frame")
mmf$formula <- Formula(formula)
mmf <- eval(mmf, parent.frame())
if(!missingArg(row.names)) row.names <- as.vector(as.character(model.extract(mmf,row.names)))
mx <- model.part(Formula(formula), data = mmf, rhs = 1, terms = TRUE)
D <- model.matrix(mx, data = mmf)
if(attr(terms(mx),"intercept")){
Dnames <- colnames(D)
D <- matrix(D[,-1],ncol=length(Dnames)-1)
colnames(D) <- Dnames[-1]
}
k <- ncol(D)
if(regim > 1){
mz <- model.part(Formula(formula), data = mmf, rhs = 2, terms = TRUE)
Z <- model.matrix(mz, data = mmf)
if(attr(terms(mz),"intercept")){
Znames <- colnames(Z)
Z <- as.matrix(Z[,-1])
colnames(Z) <- Znames[-1]
}
}
if(!is.null(ars$q)){
mx2 <- model.part(Formula(formula), data = mmf, rhs = 3, terms = TRUE)
X2 <- model.matrix(mx2, data = mmf)
if(attr(terms(mx2),"intercept")){
X2names <- colnames(X2)
X2 <- as.matrix(X2[,-1])
colnames(X2) <- X2names[-1]
}
r <- ncol(X2)
}else ars$q <- rep(0,regim)
if(is.null(ars$d)) ars$d <- rep(0,regim)
data <- list()
chains <- list()
rep <- n.sim*n.thin + n.burnin
ids <- matrix(seq(1,n.sim*n.thin*k,k))
ids <- ids[seq(1,n.sim*n.thin,n.thin)]
ids <- n.burnin*k + as.vector(apply(matrix(ids),1,function(x) x + c(0:(k-1))))
Sigmanew2 <- list()
name <- list()
if(regim > 1) ps <- max(ars$p,ars$q,ars$d,hmax) else ps <- max(ars$p,ars$q,ars$d)
if(regim > 1){
Zs <- Z[(ps+1-hmin):(nrow(D)-hmin),]
t1 <- max(Zs);t0 <- min(Zs)
thresholds <- quantile(Zs,probs=c(1:(regim-1))/regim)
regs <- cut(Zs,breaks=c(-Inf,sort(thresholds),Inf),labels=FALSE)
thresholds.chains <- matrix(thresholds,regim-1,1)
hs.chains <- matrix(hmin,1,1)
}else regs <- matrix(1,nrow(D)-ps,1)
for(i in 1:regim){
y <- matrix(D[(ps+1):nrow(D),1:k],ncol=k)
X <- matrix(1,nrow(y),1)
for(j in 1:ars$p[i]) X <- cbind(X,D[((ps+1)-j):(nrow(D)-j),])
name[[i]] <-  c("(Intercept)",paste0(rep(colnames(D)[1:k],ars$p[i]),sort(paste0(".lag(",rep(1:ars$p[i],k))),")"))
if(!Intercept){
X <- matrix(X[,-1],nrow(X),ncol(X)-1)
name[[i]] <- name[[i]][-1]
}
if(ars$q[i]!=0){
for(j in 1:ars$q[i]) X <- cbind(X,X2[((ps+1)-j):(nrow(D)-j),])
name[[i]] <- c(name[[i]],paste0(rep(colnames(X2),ars$q[i]),sort(paste0(".lag(",rep(1:ars$q[i],r))),")"))
}
if(ars$d[i]!=0){
for(j in 1:ars$d[i]) X <- cbind(X,Z[((ps+1)-j):(nrow(D)-j),])
name[[i]] <- c(name[[i]],paste0(rep(colnames(Z),ars$d[i]),sort(paste0(".lag(",1:ars$d[i])),")"))
}
colnames(X) <- name[[i]]
if(!missingArg(row.names)){
row.names2 <- row.names[(ps+1):nrow(D)]
rownames(X) <- rownames(y) <- row.names2
}
colnames(y) <- colnames(D)
data[[i]] <- list()
data[[i]]$y <- y
data[[i]]$X <- X
places <- regs == i
X <- matrix(X[places,],sum(places),ncol(X))
y <- matrix(y[places,],nrow(X),ncol(y))
b0 <- chol2inv(chol(crossprod(X)))
betanew <- b0%*%crossprod(X,y)
Sigmanew <- crossprod(y-X%*%betanew)/nrow(X)
Sigmanew2[[i]] <- chol2inv(chol(Sigmanew))
chains[[i]] <- list()
chains[[i]]$location <- betanew
chains[[i]]$scale <- Sigmanew
}
tol <- unlist(lapply(data,function(x) ncol(x$X)))*1.2
us <- matrix(1,nrow(data[[1]]$X),1)
ss <- matrix(0,nrow(data[[1]]$X),1)
if(is.null(prior$mu0)) prior$mu0 <- 0
if(is.null(prior$SigmaC)) prior$SigmaC <- 1000000000
if(is.null(prior$Omega0)) prior$Omega0 <- matrix(1/prior$SigmaC,k,k)
if(is.null(prior$tau0)) prior$tau0 <- k
if(dist=="Hyperbolic"){
if(is.null(prior$gamma0)) prior$gamma0 <- 0.1
if(is.null(prior$eta0)) prior$eta0 <- 5
chains$extra <- matrix(1.85,1,1)
nus <- matrix(seq(prior$gamma0,prior$eta0,length=501),501,1)
num1 <- nus[2:length(nus)] - nus[1:(length(nus)-1)]
num2 <- (nus[2:length(nus)] + nus[1:(length(nus)-1)])/2
resto <- log(nus) - log(besselK(nus,1))
}
if(dist=="Student-t"){
if(is.null(prior$gamma0)) prior$gamma0 <- 1
if(is.null(prior$eta0)) prior$eta0 <- 80
chains$extra <- matrix(100,1,1)
nus <- matrix(seq(prior$gamma0,prior$eta0,length=501),501,1)
num1 <- nus[2:length(nus)] - nus[1:(length(nus)-1)]
num2 <- (nus[2:length(nus)] + nus[1:(length(nus)-1)])/2
resto <- (nus/2)*log(nus/2) - lgamma(nus/2)
}
if(dist=="Slash"){
chains$extra <- matrix(100,1,1)
if(is.null(prior$gamma0)) prior$gamma0 <- 1/1000000000
if(is.null(prior$eta0)) prior$eta0 <- 1/1000000000
}
if(dist=="Contaminated normal"){
chains$extra <- matrix(c(0.01,0.99),2,1)
if(is.null(prior$gamma01)) prior$gamma01 <- 1/1000000000
if(is.null(prior$eta01)) prior$eta01 <- 1/1000000000
if(is.null(prior$gamma02)) prior$gamma02 <- 1/1000000000
if(is.null(prior$eta02)) prior$eta02 <- 1/1000000000
}
bar <- txtProgressBar(min=0, max=rep, initial=0, width=min(50,rep), char="+", style=3)
for(j in 1:rep){
if(regim > 1){
hs <- hs.chains[,j]
thresholds <- thresholds.chains[,j]
regs <- cut(Z[(ps+1-hs):(nrow(D)-hs),],breaks=c(-Inf,sort(thresholds),Inf),labels=FALSE)
}
for(i in 1:regim){
places <- regs == i
X <- matrix(data[[i]]$X[places,],sum(places),ncol(data[[i]]$X))
n <- nrow(X); s <- ncol(X)
y <- matrix(data[[i]]$y[places,],n,ncol(data[[i]]$y))
mu0s <- matrix(prior$mu0,s,k)
Sigmarinv <- matrix(1/prior$SigmaC,s,s)
if(dist=="Gaussian") us[places] <- rep(1,n)
else{
resu <- y-X%*%chains[[i]]$location[,(1+(j-1)*k):(j*k)]
usi <- apply(t(resu)*tcrossprod(Sigmanew2[[i]],resu),2,sum)
}
if(dist=="Laplace")
us[places] <- apply(matrix(usi,length(usi),1),1,function(x) 1/rgig(n=1,lambda=(2-k)/2,chi=x,psi=1/4))
if(dist=="Hyperbolic")
us[places] <- apply(matrix(usi,length(usi),1),1,function(x) 1/rgig(n=1,lambda=(2-k)/2,chi=x+1,psi=chains$extra[,j]^2))
if(dist=="Student-t"){
us[places] <- rgamma(n,shape=(chains$extra[,j]+k)/2,scale=2/(chains$extra[,j]+usi))
}
if(dist=="Slash"){
u0 <- pgamma(q=1,shape=(chains$extra[,j]+k)/2,scale=2/usi)
us[places] <- qgamma(p=runif(n)*u0,shape=(chains$extra[,j]+k)/2,scale=2/usi)
us[places] <- ifelse(us[places]<.Machine$double.xmin,.Machine$double.xmin,us[places])
}
if(dist=="Contaminated normal"){
a <- chains$extra[1,j]*chains$extra[2,j]^(k/2)*exp(-chains$extra[2,j]*usi/2)
b <- (1-chains$extra[1,j])*exp(-usi/2)
us[places] <- ifelse(runif(n)<=a/(a+b),chains$extra[2,j],1)
}
usi <- us[places]
Xu <- matrix(sqrt(usi),n,s)*X
yu <- matrix(sqrt(usi),n,k)*y
A <- chol2inv(chol(Sigmarinv + crossprod(Xu)))
M <- A%*%(crossprod(Xu,yu) + Sigmarinv%*%mu0s)
betanew <- M + t(chol(A))%*%matrix(rnorm(s*k),s,k)%*%chol(chains[[i]]$scale[,(1+(j-1)*k):(j*k)])
chains[[i]]$location <- cbind(chains[[i]]$location,betanew)
Omega <- prior$Omega0 + crossprod(betanew-mu0s,Sigmarinv)%*%(betanew-mu0s) + crossprod(yu-Xu%*%betanew)
Omegachol <- chol(chol2inv(chol(Omega)))
Sigmanew2[[i]] <- tcrossprod(t(Omegachol)%*%matrix(rnorm(k*(prior$tau0+s+n)),k,prior$tau0+s+n))
Sigmanew <- chol2inv(chol(Sigmanew2[[i]]))
chains[[i]]$scale <- cbind(chains[[i]]$scale,Sigmanew)
if(dist=="Contaminated normal"){
resu <- y-X%*%betanew
ss[places] <- apply(t(resu)*tcrossprod(Sigmanew2[[i]],resu),2,sum)
}
}
if(dist=="Hyperbolic"){
etanew <- length(us)*resto - (1/2)*(nus^2*sum(1/us))
etanew <- exp(etanew - max(etanew))
probs <- num1*(etanew[2:length(nus)] + etanew[1:(length(nus)-1)])/2
etanew <- sample(x=num2,size=1,prob=probs/sum(probs))
chains$extra <- cbind(chains$extra,matrix(etanew,1,1))
}
if(dist=="Student-t"){
etanew <- length(us)*resto +	(nus/2)*sum(log(us)-us)
etanew <- exp(etanew - max(etanew))
probs <- num1*(etanew[2:length(nus)] + etanew[1:(length(nus)-1)])/2
etanew <- sample(x=num2,size=1,prob=probs/sum(probs))
chains$extra <- cbind(chains$extra,matrix(etanew,1,1))
}
if(dist=="Slash"){
etanew <- rgamma(1,shape=prior$gamma0+length(us),scale=2/(prior$eta0-sum(log(us))))
chains$extra <- cbind(chains$extra,matrix(etanew,1,1))
}
if(dist=="Contaminated normal"){
a <- us==chains$extra[2,j]
etanew1 <- max(0.01,rbeta(1,shape1=prior$gamma01+sum(a),shape2=prior$eta01+length(a)-sum(a)))
u0 <- pgamma(q=1,shape=(sum(a)*k + prior$gamma02)/2,scale=2/(prior$eta02 + sum(ss*a)))
etanew2 <- max(0.01,qgamma(p=runif(1)*u0,shape=(sum(a)*k + prior$gamma02)/2,scale=2/(prior$eta02 + sum(ss*a))))
chains$extra <- cbind(chains$extra,matrix(c(etanew1,etanew2),2,1))
}
Loglik <- function(h,thresholds){
regs <- cut(Z[(ps+1-h):(nrow(D)-h),],breaks=c(-Inf,sort(thresholds),Inf),labels=FALSE)
result <- 0
for(i in 1:regim){
places <- regs == i
X <- matrix(data[[i]]$X[places,],sum(places),ncol(data[[i]]$X))
y <- matrix(data[[i]]$y[places,],nrow(X),ncol(data[[i]]$y))
usi <- us[places]
Xu <- matrix(sqrt(usi),nrow(X),ncol(X))*X
yu <- matrix(sqrt(usi),nrow(X),k)*y
resu <- yu-Xu%*%chains[[i]]$location[,(ncol(chains[[i]]$location)- k + 1):ncol(chains[[i]]$location)]
ds <- apply(t(resu)*tcrossprod(Sigmanew2[[i]],resu),2,sum)
result <- result -0.5*sum(ds - log(det(Sigmanew2[[i]])) - k*log(usi) + k*log(2*pi))
}
return(result)
}
if(regim > 1){
a0 <- (thresholds.chains[,j] - t0)/(t1 - t0)
if(length(a0) > 1) a0 <- c(a0[1],diff(a0))
ind <- TRUE
while(ind){
r0 <- rgamma(length(a0)+1,shape=c(a0,1-sum(a0)),scale=1)
r0 <- r0[-length(a0)-1]/sum(r0)
thresholds.new <- t0 + cumsum(r0)*(t1 - t0)
ind <- any(table(cut(Z[(ps+1-hs):(nrow(D)-hs),],breaks=c(-Inf,sort(thresholds.new),Inf),labels=FALSE)) < tol)
}
a <- min(1,exp(Loglik(hs,thresholds.new) - Loglik(hs,thresholds.chains[,j]) +
sum((r0-1)*log(a0) - lgamma(r0)) + lgamma(sum(r0)) - sum((a0-1)*log(r0) - lgamma(a0)) - lgamma(sum(a0))))
if(runif(1) > a) thresholds.new <- thresholds.chains[,j]
thresholds.chains <- cbind(thresholds.chains,thresholds.new)
resul <- vector()
for(h in hmin:hmax) resul <- c(resul,Loglik(h,thresholds.new))
resul <- resul-max(resul)
resul <- exp(resul)/sum(exp(resul))
hs.chains <- cbind(hs.chains,sample(hmin:hmax,size=1,prob=resul))
}
setTxtProgressBar(bar,j)
}
cat("\n")
for(i in 1:regim){
chains[[i]]$location <- chains[[i]]$location[,ids]
rownames(chains[[i]]$location) <- name[[i]]
chains[[i]]$scale <- matrix(chains[[i]]$scale[,ids],nrow=k,ncol=k*n.sim)
colnames(chains[[i]]$scale) <- rep(colnames(D),n.sim)
rownames(chains[[i]]$scale) <- colnames(D)
}
if(dist %in% c("Student-t","Hyperbolic","Slash","Contaminated normal"))
chains$extra <- matrix(chains$extra[,n.burnin + seq(1,n.sim*n.thin,n.thin)],ncol=n.sim)
out_ <- list(data=data,chains=chains,n.sim=n.sim,regim=regim,name=name,dist=dist,ps=ps,ars=ars,formula=Formula(formula),Intercept=Intercept,call=match.call())
if(regim > 1){
out_$chains$thresholds <- matrix(thresholds.chains[,n.burnin + seq(1,n.sim*n.thin,n.thin)],ncol=n.sim)
out_$chains$h <- hs.chains[,n.burnin + seq(1,n.sim*n.thin,n.thin)]
out_$threshold.series=Z
out_$ts=paste0(colnames(Z),".lag(",mean(out_$chains$h),")")
if(max(ars$q) > 0) out_$covariable.series=X2
out_$response.series=D
}
class(out_) <- "mtar"
return(out_)
}
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.2; extra_2_contaminated=0.7
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.2; extra_2_contaminated=0.7
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.2; extra_2_contaminated=0.7
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.2; extra_2_contaminated=0.7
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.7; extra_2_contaminated=0.4
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
calen=100
long=1000
h.ahead=10
Tlen = long+calen+h.ahead
dimeUt=3
Sigma_ut = diag(2,dimeUt,dimeUt) ##Matriz diagonal
Phi_ut = list(phi1 = matrix(c(0.24,0.48,-0.12,0.46,-0.36,0.1,-0.12,-0.47,0.58),dimeUt,dimeUt,byrow = TRUE))
R_ut = list(R1 = mtaregime(orders = list(p = 1,q = 0,d = 0),Phi = Phi_ut,Sigma = Sigma_ut))
Ut = mtarsim(N = Tlen,Rg = R_ut,seed = NULL)
Zt = Ut$Sim$Yt[,3]
k = 3
#v=2
v=0
### R1 regimen ====
Phi_R1 = list(phi1 = matrix(c(0.1,0.6,0.8,-0.4,0.5,-0.7,0.2,0.6,-0.8),k,k,byrow = TRUE))
Sigma_R1 = matrix(c(1,0,0,0,1,0,0,0,1),k,k,byrow = TRUE)
cs_1=matrix(c(1,-2,6),nrow=k)
R1 = mtaregime(orders = list(p = 1,q = 0,d = 0),Phi = Phi_R1,Sigma = Sigma_R1,cs=cs_1)
### R2 regimen ====
Phi_R2 = list(phi1 = matrix(c(0.3,0.5,-0.5,0.2,0.7,-0.1,0.3,-0.4,0.8),k,k,byrow = TRUE))
#Beta_R2=list(beta1=matrix(c(0.3,0.5,-0.2,0.7,0.3,-0.5),k,v,byrow = TRUE))
Sigma_R2 = matrix(c(2.5,0.0,0.0,0.0,1,0.0,0.0,0.0,4),k,k,byrow = TRUE)
cs_2=matrix(c(0,0,0),nrow=k)
#R2 = mtaregime(orders = list(p = 1,q = 1,d = 0),
#               Phi = Phi_R2,Beta = Beta_R2,Sigma = Sigma_R2)
R2 = mtaregime(orders = list(p = 1,q = 0,d = 0),
Phi = Phi_R2,Sigma = Sigma_R2,cs=cs_2)
## crea lista de objeto tipo Regime
Rg = list(R1 = R1,R2 = R2)
r = 0.0
extra_1_contaminated=0.7; extra_2_contaminated=0.4
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
summarymtar <- function(object, credible=0.95, digits=5,...){
k <- ncol(object$data[[1]]$y)
n.sim <- object$n.sim
out_ <- list()
resumen <- function(x){
x <- matrix(x,ifelse(is.null(nrow(x)),1,nrow(x)),ifelse(is.null(ncol(x)),length(x),ncol(x)))
y <- matrix(0,nrow(x),5)
y[,1] <- apply(x,1,mean)
y[,2] <- apply(x,1,sd)
y[,3] <- apply(x,1,function(x) min(mean(sign(median(x))*x > 0),1-1/200000))
y[,3] <- 2*(1 - y[,3])
ks <- seq(credible,1,length=n.sim*(1-credible))
lis <- t(apply(x,1,quantile,probs=ks-credible))
lss <- t(apply(x,1,quantile,probs=ks))
dif <- apply(abs(lss-lis),1,which.min)
y[,4] <- lis[cbind(1:nrow(x),dif)]
y[,5] <- lss[cbind(1:nrow(x),dif)]
colnames(y) <- c("   Mean"," Std.Dev"," 2(1-PD) ","HDI_Low","HDI_high")
return(y)
}
if(object$regim > 1){
thresholds <- matrix(round(resumen(matrix(object$chains$thresholds,nrow=object$regim-1)),digits=digits)[,c(1,4,5)],ncol=3)
h <- round(mean(object$chains$h),digits=0)
thresholds1 <- paste0(c("(-Inf",paste0("(",round(thresholds[,1],digits=digits))),",",c(paste0(round(thresholds[,1],digits=digits),"]"),"Inf)"))
thresholds2 <- paste0(c("(-Inf",paste0("(",round(thresholds[,2],digits=digits))),",",c(paste0(round(thresholds[,2],digits=digits),"]"),"Inf)"))
thresholds3 <- paste0(c("(-Inf",paste0("(",round(thresholds[,3],digits=digits))),",",c(paste0(round(thresholds[,3],digits=digits),"]"),"Inf)"))
d <- data.frame(cbind(thresholds1,thresholds2,thresholds3))
rownames(d) <- paste("Regime",1:nrow(d))
colnames(d) <- rep(" ",3)
}
cat("\nResponse          :",ifelse(length(colnames(object$data[[1]]$y))==1,colnames(object$data[[1]]$y),paste(colnames(object$data[[1]]$y),collapse="    |    ")))
if(object$regim > 1) cat("\nThreshold series  :",object$ts,"(Mean)")
cat("\nError distribution:",object$dist)
cat("\n\n")
if(object$regim > 1){
cat("\nThresholds (Mean, HDI_low, HDI_high)\n")
print(d)
out_$thresholds <- d
out_$location <- list()
out_$scale <- list()
}
for(i in 1:object$regim){
out <- outs <- vector()
for(j in 1:k){
temp <- object$chains[[i]]$location[,seq(j,n.sim*k,k)]
temps <- matrix(matrix(object$chains[[i]]$scale,k,n.sim*k)[,seq(j,n.sim*k,k)],nrow=k)
if(j > 1){
out <- cbind(out,matrix(0,nrow(out),1),round(resumen(temp),digits=digits))
outs <- cbind(outs,round(resumen(temps)[,c(1,4,5)],digits=digits+1))
}
else{
out <- round(resumen(temp),digits=digits)
outs <- round(resumen(temps)[,c(1,4,5)],digits=digits+1)
}
}
rownames(out) <- object$name[[i]]
outs <- matrix(cbind(outs,0),k,3*k+1)
outs <- outs[,c(seq(1,3*k,3),3*k+1,seq(2,3*k,3),3*k+1,seq(3,3*k,3))]
rownames(outs) <- colnames(object$data[[1]]$y)
colnames(outs) <- c(rownames(outs),"",rownames(outs),"",rownames(outs))
cat("\n\nRegime",i,":")
cat("\nAutoregressive coefficients\n")
print(format(out, justify = "right", format = "+/-", zero.print="   |   "), quote=FALSE)
cat("\nScale parameter (Mean, HDI_low, HDI_high)\n")
print(format(outs, justify = "right", format = "+/-", zero.print="   ."), quote=FALSE)
out_$location[[i]] <- out
out_$scale[[i]] <- outs
}
if(object$dist %in% c("Slash","Contaminated normal","Student-t","Hyperbolic")){
out <- round(resumen(object$chains$extra),digits=digits+1)
out[,3] <- 0
if(object$dist %in% c("Slash","Student-t","Hyperbolic")) rownames(out)[nrow(out)] <- paste0("nu",paste0(rep("",max(nchar(object$name[[1]]))-1),collapse=" "))
else rownames(out)[nrow(out):(nrow(out)-1)] <- paste0(c("nu2","nu1"),paste0(rep("",max(nchar(object$name[[1]]))-2),collapse=" "))
cat("\n\nExtra parameter","\n")
print(format(out, justify = "right", flag="+", zero.print="   .   "), quote=FALSE)
out_$extra <- out
}
cat("\n\n")
return(invisible(out_))
}
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
calen=100
long=1000
h.ahead=10
Tlen = long+calen+h.ahead
dimeUt=3
Sigma_ut = diag(2,dimeUt,dimeUt) ##Matriz diagonal
Phi_ut = list(phi1 = matrix(c(0.24,0.48,-0.12,0.46,-0.36,0.1,-0.12,-0.47,0.58),dimeUt,dimeUt,byrow = TRUE))
R_ut = list(R1 = mtaregime(orders = list(p = 1,q = 0,d = 0),Phi = Phi_ut,Sigma = Sigma_ut))
Ut = mtarsim(N = Tlen,Rg = R_ut,seed = NULL)
Zt = Ut$Sim$Yt[,3]
k = 3
#v=2
v=0
### R1 regimen ====
Phi_R1 = list(phi1 = matrix(c(0.1,0.6,0.8,-0.4,0.5,-0.7,0.2,0.6,-0.8),k,k,byrow = TRUE))
Sigma_R1 = matrix(c(1,0,0,0,1,0,0,0,1),k,k,byrow = TRUE)
cs_1=matrix(c(1,-2,6),nrow=k)
R1 = mtaregime(orders = list(p = 1,q = 0,d = 0),Phi = Phi_R1,Sigma = Sigma_R1,cs=cs_1)
### R2 regimen ====
Phi_R2 = list(phi1 = matrix(c(0.3,0.5,-0.5,0.2,0.7,-0.1,0.3,-0.4,0.8),k,k,byrow = TRUE))
#Beta_R2=list(beta1=matrix(c(0.3,0.5,-0.2,0.7,0.3,-0.5),k,v,byrow = TRUE))
Sigma_R2 = matrix(c(2.5,0.0,0.0,0.0,1,0.0,0.0,0.0,4),k,k,byrow = TRUE)
cs_2=matrix(c(0,0,0),nrow=k)
#R2 = mtaregime(orders = list(p = 1,q = 1,d = 0),
#               Phi = Phi_R2,Beta = Beta_R2,Sigma = Sigma_R2)
R2 = mtaregime(orders = list(p = 1,q = 0,d = 0),
Phi = Phi_R2,Sigma = Sigma_R2,cs=cs_2)
## crea lista de objeto tipo Regime
Rg = list(R1 = R1,R2 = R2)
r = 0.0
extra_1_contaminated=0.7; extra_2_contaminated=0.4
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.3; extra_2_contaminated=0.5
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.5; extra_2_contaminated=0.3
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
extra_1_contaminated=0.5; extra_2_contaminated=0.5
datasim_Contaminated = mtarsim_mixture(N = Tlen,Rg = Rg,r = r,Zt = Zt,seed = NULL,Tinic=100,delay = 1,Distribution = "Contaminated normal",extra_1=extra_1_contaminated,extra_2 = extra_2_contaminated)
### Creación de las fechas para datos simulados====
Fechas=seq(as.Date("2000/1/1"), by = "day", length.out = (Tlen-calen))
datos1_Contaminated=data.frame(cbind(datasim_Contaminated$Sim$Yt,datasim_Contaminated$Zt_orig),Fecha=Fechas)
##  Procedimiento de Estimación Bayesiano ====
fecha_final<-Fechas[long]
fit1_Bayes_contaminated <- mtar(~X1+X2+X3|X4, data=datos1_Contaminated, row.names=Fecha,subset={Fecha<=fecha_final} ,ars=list(p=c(1,1)), dist="Contaminated normal", n.burnin=500, n.sim=1500, n.thin=1)
summary_contaminated<-summarymtar(fit1_Bayes_contaminated)
